##################
BROWSERSYNC + GULP
###################################
I.	INSTALL AND REQUIRE
II.	STREAMS AND RELOAD
III.	EDIT A LIVE SITE LOCALLY
###################################

#########################
I.	INSTALL AND REQUIRE
#########################

It is important to not just require in BS but to create() and instance of it. You could create multiple instances.

 	npm -i --save-dev browser-sync

	bs = require('browser-sync').create();

Browser-sync can be configured to run as a simple STATIC file server, or as a PROXY for your own backend server (EXPRESS) that may already be running on localhost or in a Virtual Box (Vagrant).
  
You configure the browser-sync server in the gulp WATCH task with the init() method that accepts an OBJECT with the config options.

A.	STATIC SERVER 

 	function watchTask(){
		bs.init({
			server: {baseDir: './app'}
		})
	}

B.	PROXY

Proxy an EXISTING virtual host. Browsersync will wrap your vhost with a proxy URL to view your site.

The proxy is the URL of the Express localhost server or the remote server you are working with. In the example below the server runs on localhost port 4000. Use a different port to run the bs proxy through.

In the proxy config object you indicate what address to open in the browser. This can be the LOCAL for localhost, EXTERNAL, FALSE or TUNNEL.

If you set the option to TUNNEL: '<name>' the app will be available on your local network at:
	
	<name>.localtunnel.me

You can add a subfolder if you have multiple apps running on the same server.

 	browser-sync.init({
		open: "local",			
		proxy: "http://localhost:4000/<subfolder>",	
		port: 3000,
		tunnel: '<name>'
	});

########################
II.	STREAMS AND RELOAD
########################

A.	STREAMS

The stream functionality allows for browser-sync to inject css/sass into the browsers without reloading. Once the stream is has reached it's dest() you add another pipe(bs.stream()) wherin you call the stream() method.

NOTE! There is an issue with injectings styles through GULP .pipe(bs.stream()) when using a PROXY. Use the browser-sync native option FILES instead. In the bs.init({}) add the files: '<path>/*.css' option.

Sass will process your sass files into a main.css. When that changes browser-sync will be watching and inject the styles.
	

B.	AUTOMATIC RELOAD BROWSERS ON WATCH FILES

Add an event listener to the watch task and call the reload method.

	watch(htmlFiles).on('change', bsReload)
	
The browser-sync method reload() is not an async function but GULP WATCH is async and needs to know when tasks have been completed. 

The result is that a task with a bs.reload method in it will run only ONCE. Because if nothing is returned from a task, as in bs.reload, you must use the error-first callback to signal completion. 

To fix this behavior wrap the bs.reload in a seperate function using an error-first callback:
	
 	function bsReload(cb){
    		bs.reload();
    		cb(new Error('Error while reloading browsers'));
	};

C.	WATCH FILES IN BROWSERSYNC OPTIONS

What seems to work best is to have the files to watch indicated in the FILES options of browserSync config.

 	browser-sync.init({
		open: "local",			
		proxy: "http://localhost:4000/<subfolder>",	
		port: 3000,
		tunnel: '<name>'
		files: ['cssPath','htmlPath','jsPath']
	});


############################
III.	EDIT LIVE SITE LOCALLY
############################

Without having to setup a dev environment with the full code you can proxy the live site through Browser-Sync and work on changes that later have to be entered into the real production code.


REFERENCE:
https://medium.com/@markbrouch/edit-live-sites-on-the-fly-with-browsersync-426690dac3f1