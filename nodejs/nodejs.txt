######
NODEJS
##################################
I. 	ABOUT NODEJS
II. 	NODE CONSOLE
III.	NODEJS ENVIRONMENT VARIABLES
IV.	ARGUMENTS-CONSOLE-ERROR
V.	OS MODULES AND EVENTS MODULE
##################################

##################
I.	ABOUT NODEJS
##################

Javascript was originally used as a browser language only in contrast to back-end languages that could talk to servers and do database operations.

NodeJs brings a runtime system or environment that adds extra use cases for JS:

- communicate with servers and store or return data from databses
- use JS as a dev tool on a pc to write scripts and automate tasks

In the NodeJS environment JS files can be interpreted and evaluated for us and it comes with built-in methods and packages. 

Through NodeJs you can, for example, access the local file system and the Internet to grab and modify files.

Some differences with the browser: you control the environment (instead of unknown client browser type), no DOM, CommonJS modules (thus require() vs ES6 import).

The V8 JS engine is written in C++, and it's continuously improved. It is portable and runs on Mac, Windows,
Linux and several other systems. It compiles and executes the JS. JavScript is internally compiled by V8 with just-in-time (JIT) compilation to speed up the execution.

WHEN TO USE

NODEJS is single-threated, thus at any given point in time the code execution is done by one single processing thread. The processing thread runs through a QUEUE of EVENTS one by one. 
The implementation is done through the EVENT LOOP.

The potential problem with this single-threated approach is that a processor intensive task may block the application execution. But, since JS and NODEJS are ASYNCHRONOUS the most common time-consuming tasks, such as network requests, are treated as asynchronous events. This means that the code execution will continue while the time consuming task is being executed. Once that task is completed, a CALLBACK is function is added to the QUEUE of events to be executed.

Other platforms that are multi-threaded work with a thread pool. As long as there are IDLE threads, new instructions can be added while the BUSY threads are waiting for a task to be completed before they can resume execution because these threads are SYNCHRONOUS.

Because there is no thread pool nodejs is very efficient in dealing with I/O or database intensive apps. Idle threads don't exist and the thread pool cannot be full. Thus examples of where nodejs shines are webservers, realtime servers (websocket)


For an application that needs intensive internal computation, nodejs is not very efficient because the work needs to be done on the one and only available thread. When the app does not depend on an external API to do the heavy lifiting, the single thread may get blocked.



##################
II. 	NODE CONSOLE
##################

REPL
- Read your command line instructions, 
- Evaluate the related code, 
- Print the result, 
- Loop back to the command line to wait further instructions

In this REPL environment you can write valid js directly.

By typing node you can perform JS in the CLI just as in the browser console. Obviously there is no browser in the CLI thus no DOM maniplation with selectors, no .document, etc.

Run a JS file in the CLI:
		
	node file.js

Exiting a node program.

In the app.js code you can you use PROCESS core module which has methods like .exit().

	process.exit()

When Node.js runs this line, the process is immediately forced to terminate. This means that any callback that's pending, any network request still being sent, any filesystem access, or processes writing to stdout or stderr - all is going to be ungracefully terminated right away.

Node.js will normally exit with a 0 status code when no more async operations are pending. For more status codes, see docs.

SIGTERM 

SIGTERM is the signals that tells a process to gracefully terminate. 

A server app.js program, for example, is never going to end. If you call process.exit() , any currently pending or
running request is going to be aborted. With SIGTERM a notification is sent to a process in order to notify it of an event that occurred (POSIX, intercommunication system).
	
	const server = app.listen(3000, () => console.log('Server 	ready'))
	
	process.on('SIGTERM', () => {
		server.close(() => {
			console.log('Process terminated')
		})
	})

###########################
III.	ENVIRONMENT VARIABLES
###########################

They should be used to keep sensible data secure in JavaScript applications, but shouldn’t be shared on public GitHub repositories when using git.

In JS file, at the top import or require the dotenv package
	
	npm install dotenv --save-dev
	require('dotenv').config()

	touch .env
	echo > 	MY_SECRET=mysupersecretpassword
			DB_HOST=localhost
			DB_USER=root
			DB_PASS=s1mpl3

	In the JS script application code:

	db.connect({
  		host: process.env.DB_HOST,
  		username: process.env.DB_USER,
  		password: process.env.DB_PASS
	})

NOTE: exclude the .env from git


#############################
IV.	ARGUMENTS-CONSOLE-ERROR
#############################

The PROCESS object has an ARGV property, which is an array that contains all the command line invocation arguments.

The first argument is the full path of the node command.

The second element is the full path of the file being executed.

All the additional arguments are present from the third position going forward.

STDOUT-STDERR

Console.log prints to the standard output, which is the node terminal.

The console.error prints to the standard error stream and will not show up in the console, but it will appear in the error log.

##################################
V.	OS MODULES AND EVENTS MODULE
##################################

EVENT LOOP

The event loop in Nodejs is SINGLE-THREADED or SYNCHRONOUS, thus no two lines of JS can be running at the same time and everything is executed in order. This contrast with MULTI-THREADED programs that can have multiple JS executions running at the same time or in parallel.

The event loop however does let Nodejs achieve CONCURRENCY (but not parallelism). This makes Nodejs ASYNCHRONOUS. Thus actions like reading from the filesystem, waiting for server responses etc, that happen outside the program itself, do not have to block the progress of our program execution, those can be done concurrently.

For example, a setTimeout function at 0 ms will be added to the callback queue and executed at the end of the Event loop of the program. Nothing is happening in parallel outside the program. The asynchronous setTimeout, just delays the execution to a further point in the Event Loop but an async function does return immediately and allows the Event Loop to advance.

Another example would be the fs.readFile module which puts the callback function on the callback queue and returns immediately. This allows the program to advance while the reading of that file is in progress. 

The callback queue is first in first out, thus if you read from multiple files it's impossible to predict which one finishes first.

	for(let i = 1; i <=5; i++){
		fs.readFile('file-' + i +'.txt', (err, data) => 					console.log(data))
	};
	Each run of this program will harvest different result:
	//-> content of file1, file3, file2, file5, file4
	//-> content of file3, file1, file2, file4, file5


The events module provides us the EventEmitter class, which is key to working with events in Node.

OS modules allows you to interact with the OS.

